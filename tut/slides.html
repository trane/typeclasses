<!DOCTYPE html>
<html>
  <head>
    <title>Type Classes</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif', 'Helvetica'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz', 'Gill Sans';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono', 'Consolas', 'Courier New'; }
    </style>
  </head>
  <body>
    <textarea id="source">

```tut:invisible
object Deserialize {
  def as[A](s: String): Option[A] = None
}
```

class: center, middle

<h1>Type Classes</h1>

Andrew Kuhnhausen • `@kuhnhausen` • Domino Data Lab

16 November 2017 • Scale by the Bay

???

- Hi, I'm Andrew.
- I write software to help data scientists focus on the science and not on operational, engineering tasks
- Before we begin, how many of you are familiar with Type-Classes or have invented your own?
- Today I'd like to walk through what I feel is a fairly canonical use case of type classes and help you gain some confidence in applying this technique

---

# Special Thanks

- Travis Brown @travisbrown https://meta.plasm.us
  - "Type classes and generic derivation"
  - prolific stackoverflow gems
- Rob Norris @tpolecat https://tpolecat.github.io
  - tut
  - f-bounded types
  - pedagogical mastery
- Jacob Odersky @jodersky
  - pointing out a workaround with `self.type`

???

- Before I begin, I wanted to just thank Travis Brown (whos work in the scala community heavily influenced
me and this talk). His post "Type classes and generic derivation" provided the narrative outline for this talk.
- And also Rob Norris,  I am using his tut library for these slides and sourced from his f-bounded types post. also, he is a shining example of how to give a technical talk. I hope that I can do my best to give this in that spirit.

---

# Goals

1. Gain an intuition about **type classes**
2. Learn a bit about type safety and making the **compiler** do some work for you
3. Gain some **confidence** in applying the type class pattern in your every day code
4. Exposure to some other **applications** of type classes

???

1. --- this pattern is well known in the FP Scala community and comes from the designers of Haskell to address some of the complexity issues of programming with generics
2. --- the scala compiler is powerful - even if slow - but it comes with the benefit of being able to remove whole classes of runtime errors if you let it
3. --- once you see the pattern, you'll start seeing how you can apply it all over the place
4. --- this pattern encompasses entire classes of problems that are addressed in other styles of programming with multiple patterns, my hope is to show you that you can apply
this technique to reduce the number of OO-patterns you need to memorize and help to simplify the code base

Ok so let's look at a canonical use case: serializing or deserializing

---

# Data types

```tut:silent
case class Person(name: String, age: Int)
case class Address(street: String, city: String, zip: Int)
case class Account(owner: String, balance: Double)
```

???

- we've defined some simple case classes that we want to be able to create from input

---

# API for Deserialization

```tut:silent
val fred = Deserialize.as[Person]("Fred,44")
val wilma = Deserialize.as[Person]("Wilma,44")
val home = Deserialize.as[Address]("1234 Bryant,San Francisco,94444")
val checking = Deserialize.as[Account]("Robert,2222.42") 
```

???

- we have a simple parsing problem
- we want to be able to create instances from a string representation that delimits fields with commas

---

# Constraints

1. The API should never throw **non-fatal** exceptions
2. Our solution should keep track at **compile-time** which types we can deserialize
3. There should be little **boilerplate**

???

1. --- so an exception like OutOfMemoryError is perfectly fine to throw, but if we see a NumberFormatException we need to handle it ourselves
so, we'll need to handle the possibility that our input strings might not be valid representations
2. --- we should never get a runtime failure (either in the form of an exception or a value representing a failure) because we tried to as
a string into a type that we don't know anything about
3. --- boilerplate is an easy way to create technical debt and bugs

---

# First go

```tut:silent
trait RowDeserialize[A] {
  def apply(s: String): A
}

val accountDeserialize: RowDeserialize[Account] =
  new RowDeserialize[Account] {
    def apply(s: String): Account = s.split(",").toList match {
      case List(owner, balance) =>
        Account(owner, balance.toDouble)
    }
  }

val addressDeserialize: RowDeserialize[Address] =
  new RowDeserialize[Address] {
    def apply(s: String): Address = s.split(",").toList match {
      case List(street, city, zip) =>
        Address(street, city, zip.toInt)
    }
  }
```

---

# First go

Now we can write the following...

```tut
accountDeserialize("Chris Yang,2.32")
addressDeserialize("548 4th St,San Francisco,94107")
```

???

- This is actually a pretty nice API because of scala's syntactic sugar on apply
- further, because we are using a generic type parameter on our deserializer, we have a useful type (not just Any)
- but, there are 3 problems

---

# Problems

1. Allows non-fatal errors to be thrown

---

# Problems

```tut:fail
accountDeserialize("Chris Yang,")
accountDeserialize("Chris Yang,Not a double")
```

---

# Problems

1. Allow non-fatal errors to be thrown
2. Have to keep track of a `RowDeserialize` instance for each type we want to deserialize

```scala
val accountDeserializer = ???
val personDeserializer = ???
val addressDeserializer = ???
// ... snip
val seriousBusinessDeserializer = ???
```

---

# Problems

1. Allow non-fatal errors to be thrown
2. Have to keep track of a `RowDeserialize` instance for each type we want to deserialize
3. We have to write a lot of boilerplate

```scala
val accountDeserialize: RowDeserialize[Account] = new RowDeserialize[Account] {
  def apply(s: String): Account = s.split(",").toList match {
    case List(owner, balance) => Account(owner, balance.toDouble)
  }
}

val addressDeserialize: RowDeserialize[Address] = new RowDeserialize[Address] {
  def apply(s: String): Address = s.split(",").toList match {
    case List(street, city, zip) => Address(street, city, zip.toInt)
  }
}

// ... and more
```

???

3. --- this is closely related to 2, we have to define instances for every one of our case classes and
those definitions are very repetitive

---

# Failing better

The first problem is easy to fix...

```tut:silent
trait RowDeserialize[A] {
  def apply(s: String): A
}

val accountDeserialize: RowDeserialize[Account] = new RowDeserialize[Account] {
  def apply(s: String): Account = s.split(",").toList match {
    case List(owner, balance) => Account(owner, balance.toDouble)
  }
}

val addressDeserialize: RowDeserialize[Address] = new RowDeserialize[Address] {
  def apply(s: String): Address = s.split(",").toList match {
    case List(street, city, zip) => Address(street, city, zip.toInt)
  }
}
```
---

# Failing better

Return an `Option` of the value:

```tut:silent
import scala.util.Try

trait SaferDeserialize[A] {
  def apply(s: String): Option[A]
}

val accountDeserialize: SaferDeserialize[Account] = new SaferDeserialize[Account] {
  def apply(s: String): Option[Account] = s.split(",").toList match {
    case List(owner, balance) =>
      Try(balance.toDouble).map(Account(owner, _)).toOption
    case _ => None
  }
}

val addressDeserialize: SaferDeserialize[Address] = new SaferDeserialize[Address] {
  def apply(s: String): Option[Address] = s.split(",").toList match {
    case List(street, city, zip) =>
      Try(zip.toInt).map(Address(street, city, _)).toOption
    case _ => None
  }
}
```

???

- we simply represent the possibility of failure with the option type
- this allows us to return failures as values

---

# Failing better

Now our api expresses the possibility that the input is invalid:

```tut
accountDeserialize("Chris Yang,2.32")
addressDeserialize("548 4th St,San Francisco,94107")
accountDeserialize("Chris Yang,")
accountDeserialize("Chris Yang,Not a double")
```

???

- And now it's impossible to make our deserialize crash with a recoverable exception -- if the input is invalid we return a None
- unfortunately, we still have to track a deserializer for each type

---
# Runtime reflection

If we were writing Java or Java-flavored Scala:

```tut:silent
import scala.reflect.ClassTag

object ReflectionDeserialize {
  def apply[A](s: String)(implicit ctag: ClassTag[A]): Option[A] = Try {
    val ctor = ctag.runtimeClass.getConstructors.head
    val parameters = s.split(",").map(_.trim).zip(ctor.getParameterTypes).map {
      case (param, cls) => cls.getName match {
        case "int" => param.toInt.asInstanceOf[Object]
        case "double" => param.toDouble.asInstanceOf[Object]
        case _ =>
          val paramCtor = cls.getConstructor(param.getClass)
          paramCtor.newInstance(param).asInstanceOf[Object]
      }
    }

    ctor.newInstance(parameters: _*).asInstanceOf[A]
  }.toOption
} // adapted from author @travisbrown
```

???

- To handle the problem of tracking an instance of `RowDeserialize` for every type, we might use reflection
To solve the syntax and boilerplate issues, and this is exactly what libraries like salat and lift-json do

---
# Runtime reflection

This works pretty nicely!

```tut
ReflectionDeserialize[Address]("548 4th St,San Francisco,94107")
ReflectionDeserialize[Person]("Fred,44")
ReflectionDeserialize[Account]("Fred,22422.49")
ReflectionDeserialize[Account]("Chris Yang,")
ReflectionDeserialize[Person]("3cpo,NaN")
```

???

- There is no boilerplate and it won't throw recoverable exception.
- The only problem is that this approach knows nothing at compile time about what types it can or can't deserialize

---
# Runtime reflection

Annoying...
```tut
ReflectionDeserialize[List[Person]]("Fred,44")
ReflectionDeserialize[Int]("548 4th St,San Francisco,94107")

trait Foo; case class Bar(a: String, b: String, i: Int) extends Foo
ReflectionDeserialize[Foo]("Domino,Data,1")
```

???

- All of these operations fail at runtime
- We could make this less annoying by using Try to represent failure and provide error values that would tell us
why the operation failed (like bad input or we don't know how to as the type), but that's still annoying

---

# Engineering Wiki Article @ Domino Data Lab

## <center>Surviving Salat</center>

???

- This is the name of an article in our wiki detailing all of the weird behavior of the library

---

# Compile-time approach

What we are aiming for...

Should compile
```scala
SaferDeserialize[Account]("Fred,2223.43")
```

Shouldn't compile
```scala
trait Foo
SaferDeserialize[Foo]("Fred,44")
```

???

- Let's go back to our saferdeserializer, which didn't let us try to as into types we don't know about and
made us keep track of our deserializer for each type individually
- We want to adapt it so that it doesn't make us do this tracking ourselves
- while also not letting us try to as any arbitrary type

---
# Compile-time approach

Let's give the type a companion object with an apply method:

```tut:silent
object SaferDeserialize {
  def apply[A](s: String)(deserialize: SaferDeserialize[A]): Option[A] =
    deserialize(s)
}
```
Which let's us write:

```tut
SaferDeserialize[Account]("Fred,1234.56")(accountDeserialize)
SaferDeserialize[Address]("123 Front St,San Francisco,94111")(addressDeserialize)
```

But not...

```tut:silent:nofail
trait Foo
SaferDeserialize[Foo]("123,456,Hello World")(???)
```

???

- This is more verbose than our original usage, but it looks more like our target usage
- but, on the bright side we simply can't as a type we don't have a deserializer for!

---
# Compile-time approach

1. It's possible to define multiple deserializers for a single type
```tut:silent:fail
SaferDeserialize[Account]("Fred,1234.56")(accountDeserialize2)
SaferDeserialize[Account]("Fred,1234.56")(accountDeserialize3)
```

???

- Let's thing about our SaferDeserialize values. It's possible to define multiple deserializers for a single type

---
# Compile-time approach

1. It's possible to define multiple deserializers for a single type
```tut:silent:fail
SaferDeserialize[Account]("Fred,1234.56")(accountDeserialize2)
SaferDeserialize[Account]("Fred,1234.56")(accountDeserialize3)
```
2. Our deserializer is meant for a single format
```tut:silent:fail
SaferDeserialize[Account]("Fred,1234.56")(theOneAccountDeserialize)
```

???
- but since it's meant to as a single format that doesn't make much sense -- in fact we could imagine a kind
of mapping from types to deserializers.

---
# Compile-time approach

1. It's possible to define multiple deserializers for a single type
```tut:silent:fail
SaferDeserialize[Account]("Fred,1234.56")(accountDeserialize2)
SaferDeserialize[Account]("Fred,1234.56")(accountDeserialize3)
```
2. Our deserializer is meant for a single format
```tut:silent:fail
SaferDeserialize[Account]("Fred,1234.56")(theOneAccountDeserialize)
```
3. Since we have a one-to-one mapping, we can imagine some kind of mapping from `A => Deserialize[A]`
```scala
SaferDeserialize[A]("some,thing")(A => Deserialize[A])
```

???

- Scala's implicit values provide one way of implementing such a mapping

---
# Compile-time approach

Imagine if we could write a mapping function from `A => Deserialize[A]`...

```scala
def mapping[A](a: A): Deserialize[A] =
  if (a.isInstanceOf[Account]) accountDeserializer
  else if (a.isInstanceOf[Person]) personDeserializer
  else if (a.isInstanceOf[Address]) addressDeserializer
  else throw new RuntimeException("No deserializer found")
```

???

That type is also known as a Map, so what if had that?

---
# Compile-time approach

Or if we had some ability to make a dynamic lookup `Map[_, Deserialize[_]]`...

```scala
def mapping[A](mapper: Map[_, Deserialize[_]]): Deserialize[A] =
  mapper.find(_.isInstanceOf[A])
        .map(_.asInstanceOf[Deserialize[A]])
        .getOrElse(throw new RuntimeException("No deserializer found"))
```

???

- the nice part is that if we had this mapping, then if some other user of our code had a new deserializer, they could simply add it to the map

---
# Compile-time approach

Or if we had some ability to make a dynamic lookup `Map[_, Deserialize[_]]`...

```scala
def mapping[A](mapper: Map[_, Deserialize[_]]): Deserialize[A] =
  mapper.find(_.isInstanceOf[A])
        .map(_.asInstanceOf[Deserialize[A]])
        .getOrElse(throw new RuntimeException("No deserializer found"))
```

We could simply add new deserializers as we needed to with some code that looks kind of like this...

```scala
class Business
globalMapper.put(Business, new Deserializer[Business] { def apply = ??? })
```

???

- the nice part is that if we had this mapping, then if some other user of our code had a new deserializer, they could simply add it to the map

---
# Compile-time approach

Remember our `SaferDeserialize`?

```tut:silent
trait SaferDeserialize[A] {
  def apply(s: String): Option[A]
}

object SaferDeserialize {
  def apply[A](s: String)(deserialize: SaferDeserialize[A]): Option[A] =
    deserialize(s)
}

val account: SaferDeserialize[Account] = new SaferDeserialize[Account] {
  def apply(s: String): Option[Account] = s.split(",").toList match {
    case List(owner, balance) =>
      Try(balance.toDouble).map(Account(owner, _)).toOption
    case _ => None
  }
}
val address: SaferDeserialize[Address] = new SaferDeserialize[Address] {
  def apply(s: String): Option[Address] = s.split(",").toList match {
    case List(street, city, zip) =>
      Try(zip.toInt).map(Address(street, city, _)).toOption
    case _ => None
  }
}
```

???

- let's make a couple of small changes to that safedeserializer

---
# Compile-time approach

We'll move the deserializers into that companion object we created...

```tut:silent
trait SaferDeserialize[A] {
  def apply(s: String): Option[A]
}

object SaferDeserialize {
  def apply[A](s: String)(deserialize: SaferDeserialize[A]): Option[A] =
    deserialize(s)

  val account: SaferDeserialize[Account] = new SaferDeserialize[Account] {
    def apply(s: String): Option[Account] = s.split(",").toList match {
      case List(owner, balance) =>
        Try(balance.toDouble).map(Account(owner, _)).toOption
      case _ => None
    }
  }

  val address: SaferDeserialize[Address] = new SaferDeserialize[Address] {
    def apply(s: String): Option[Address] = s.split(",").toList match {
      case List(street, city, zip) =>
        Try(zip.toInt).map(Address(street, city, _)).toOption
      case _ => None
    }
  }
}
```

???

- We'll move the address deserializer and account deserializer into the companion object that we created

---
# Compile-time approach

And sprinkle a few implicits...

```tut:silent
trait SaferDeserialize[A] {
  def apply(s: String): Option[A]
}

object SaferDeserialize {
  def apply[A](s: String)(implicit deserializer: SaferDeserialize[A]): Option[A] =
    deserializer(s)

  implicit val account: SaferDeserialize[Account] = new SaferDeserialize[Account] {
    def apply(s: String): Option[Account] = s.split(",").toList match {
      case List(owner, balance) =>
        Try(balance.toDouble).map(Account(owner, _)).toOption
      case _ => None
    }
  }

  implicit val address: SaferDeserialize[Address] = new SaferDeserialize[Address] {
    def apply(s: String): Option[Address] = s.split(",").toList match {
      case List(street, city, zip) =>
        Try(zip.toInt).map(Address(street, city, _)).toOption
      case _ => None
    }
  }
}
```

???

- And we'll sprinkle an implicit in front of the deserializer, and one more implicit in the apply method

---
# Compile-time approach

And now we have the usage we want...
```tut:invisible
import SaferDeserialize._
```
```tut:nofail
SaferDeserialize[Account]("Fred,1234.23")
SaferDeserialize[Address]("123 Bryant St,San Francisco,94517")

trait Foo
SaferDeserialize[Foo]("123,456,Hello World!")
```

???

- notice that we don't have to specify the deserializer instance, only the type we want to deserialize
scala's implicits create the mapping from the type to the instance of the deserializer 
- and if we try to as an unknown mapping, we get a compile-time error

---
# Compile-time approach

And now we have the usage we want...
```tut:invisible
import SaferDeserialize._
```
```tut:nofail
SaferDeserialize[Account]("Fred,1234.23")
SaferDeserialize[Address]("123 Bryant St,San Francisco,94517")

trait Foo
SaferDeserialize[Foo]("123,456,Hello World!")
```

We just discovered Type classes!

???

---

# Type classes

1. Allow us to associate operations with types **without** modifying the definitions of those types
2. Scala implements type classes via **implicit** values and **implicit** arguments
3. Other languages like Haskell or Idris have type classes as first-class language features


???

3. In fact, Haskell uses type-classes as opposed to inheritance

---
# Type classes

The structure of a type class is this:

1. `SafeDeserialize` is our type class

```scala
trait SafeDeserialize[A] {
  def apply(s: String): Option[A]
}
```
???

- we say that safedeserialize is our type class, which we use a trait and then define some interface like "apply" to it

---
# Type classes

The structure of a type class is this:

- `SafeDeserialize` is our type class

```tut:silent
trait SafeDeserialize[A] {
  def apply(s: String): Option[A]
}
```
- `SafeDeserialize[Arglebargle]` is an **instance** of `SafeDeserialize` for `Arglebargle`.

```tut:silent
case class Arglebargle(poppycock: String, applesauce: Int)
val argleDeserialize: SafeDeserialize[Arglebargle] =
  new SafeDeserialize[Arglebargle] {
    def apply(s: String): Option[Arglebargle] = ???
  }
```

---
# Type classes

The structure of a type class is this:

- `SafeDeserialize` is our type class

```tut:silent
trait SafeDeserialize[A] {
  def apply(s: String): Option[A]
}
```
- `SafeDeserialize[Arglebargle]` is an **instance** of `SafeDeserialize` for `Arglebargle`.

```tut:silent
case class Arglebargle(poppycock: String, applesauce: Int)
val argleDeserialize: SafeDeserialize[Arglebargle] =
  new SafeDeserialize[Arglebargle] {
    def apply(s: String): Option[Arglebargle] = ???
  }
```

- The `accountDeserialize` and `addressDeserialize` are `vals`, but don't have to be (objects, generic methods)

```tut:silent
object AccountDeserialize extends SafeDeserialize[Account] {
  def apply(s: String): Option[Account] = ???
}
```

---
# Type classes

The structure of a type class is this:

- `SafeDeserialize` is our type class

```tut:silent
trait SafeDeserialize[A] {
  def apply(s: String): Option[A]
}
```
- `SafeDeserialize[Arglebargle]` is an **instance** of `SafeDeserialize` for `Arglebargle`.

```tut:silent
case class Arglebargle(poppycock: String, applesauce: Int)
implicit val argleDeserialize: SafeDeserialize[Arglebargle] =
  new SafeDeserialize[Arglebargle] {
    def apply(s: String): Option[Arglebargle] = ???
  }
```

- The `accountDeserialize` and `addressDeserialize` are `vals`, but don't have to be (objects, generic methods)

```tut:silent
implicit object AccountDeserialize extends SafeDeserialize[Account] {
  def apply(s: String): Option[Account] = ???
}
```

???

- these instances are marked with "implicit" so that the compiler can create that mapping from A => SafeDeserialize

---
# Type classes

Let's say we wanted to introduce a new deserializer for some new type `Employee`:

This will fail at compile-time:
```tut:nofail
case class Employee(name: String, title: String, startDate: Long)
SaferDeserialize[Employee]("Flora,Software Engineer,1486583553")
```

---
# Type classes

We only need to have an instance of a `SaferDeserialize[Employee]`:

```tut
implicit object EmployeeDeserialize extends SaferDeserialize[Employee] {
 def apply(s: String): Option[Employee] = s.split(",").toList match {
   case List(name, title, startDate) =>
     Try(startDate.toLong).map(Employee(name, title, _)).toOption
   case _ => None
 }
}
SaferDeserialize[Employee]("Bob,Software Engineer,1486583553")
```

???

- Notice that we didn't need to touch our SafeDeserialize object
- we only had to supply an instance of our type class for employee

---
# Type classes

Instances are scoped (in complex ways)

```scala
object TestDeserialize {
  implicit val noopDeserialize: SaferDeserialize[Address] =
    new SaferDeserialize[Address] {
      def apply(s: String): Option[Address] = None
    }
  def as[A](s: String)(implicit deserializer: SaferDeserialize[A]): Option[A] =
    deserializer(s)
}
TestDeserialize.as[Account]("Fred,1234.56")
 // Some(Account(Fred,1234.56))
SaferDeserialize[Address]("123 Bryant,San Francisco,94121")
 // Some(Address(123 Bryant,San Francisco,94121))
TestDeserialize.as[Address]("123 Bryant,San Francisco,94121")
 // None
```

???

1. --- unlike haskell where an instance of a type class is global, we can actually override instances in scala
this allows a greater degree of flexibility for library writers and users to provide default implementions without fear
of making their libraries unusable
2. --- the scoping can be rather complex, but it's fairly straight-forward that scala will use the "closest" scoped implicit

---
# Type classes

We can also (type)safely do the following:

```tut:silent:fail
"Fred,1234.56".as[Account]
"123 Bryant,San Francisco,94121".as[Address]
```

???

- once you have type-safe methods you can safely add inline functions to types

---
# Type classes

Add syntactic sugar for your api:

```tut:silent
class DeserializeOps(val self: String) extends AnyVal {
  def as[A](implicit deserializer: SaferDeserialize[A]): Option[A] =
    deserializer(self)
}
trait DeserializeSyntax {
  implicit def deserializeOps(s: String): DeserializeOps =
    new DeserializeOps(s)
}
object Syntax extends DeserializeSyntax
```

???

- one really nice thing to do is provide optional inline syntactic sugar to your api
- this is some added boilerplate

---
# Type classes

Now we can **explictly** enable this sugar:

```tut
import Syntax._

"Fred,1234.56".as[Account]
"123 Bryant,San Francisco,94121".as[Address]
```

---
# Type classes

`simulacrum` brings first-class support for type classes into Scala

```tut:reset:silent
import simulacrum._
import scala.util.Try

@typeclass trait Deserialize[A] {
  def as(s: String): Option[A]
}

implicit val intDeserialize: Deserialize[Int] = new Deserialize[Int] {
  def as(s: String): Option[Int] = Try(s.toInt).toOption
}
```

```tut:nofail
Deserialize[Int].as("1234")
Deserialize[String].as("string")
```

???

- Type classes rock. Alas, their encoding in Scala requires a lot of boilerplate, which doesn't rock. There is inconsistency between projects, where type classes are encoded differently. There is inconsistency within projects, where object-oriented forwarders (aka. ops, syntax) accidentally differ in exact parameter lists or forwarders are missing where they are expected to be. Even in disciplined teams, the bike-shedding opportunities alone are a source of lost productivity.

---
# Type classes

Lawfulness:
1. We can define sets of laws that all instances must follow (like identity, associative, inverse, etc)
2. `discipline` along with `scalacheck` can test all our instances of type classes
3. These laws are shareable and composable with other laws

???

- This can give us a lot of confidence in our type classes and for the users of our type classes

---

# Type classes

It makes sense to use this pattern in a lot of places (you'll see it everywhere in FP). A non-exhaustive list is:

1. Operator overloading (method overloading)
2. Generic interfaces, e.g. `trait SomeInterface[A]`, `Numeric[A]`
3. Generating data, e.g. Scalacheck
4. Serialization, Parsing
5. As building blocks to other type-safe things, e.g. macros, shapeless
6. Functional programming with cats/scalaz
7. When you have a lot of boilerplate matching on types

???

1. In the end, things like operator overloading might be best done via inheritance.

---
# Type classes

### "In my experience I have never regretted replacing a superclass with a typeclass."
> -- Rob Norris

???

Let's take operator overloading as an example

---

# Type classes: Operator Overloading

Subclassing and wrapping classes.

```tut:reset:silent
abstract class BusinessOO {
  def doBusiness: Unit
}
class BusinessString(str: String) extends BusinessOO {
  def doBusiness: Unit  = println(s"Biz $str!")
}
class BusinessInt(int: Int) extends BusinessOO {
  def doBusiness: Unit  = println(s"Biz ${int + 1}!")
}

def doBusiness(business: BusinessOO): Unit = business.doBusiness
```

```scala
package srsbsns

class SeriousBusinessString(str: String) extends BusinessString(str) {
  override def doBusiness: Unit = println(s"Serious business $str")
}
```

---

# Type classes: Operator Overloading

With discrete typeclasses

```tut:silent
trait Business[A] {
  def apply(a: A): Unit
}
object Business {
  implicit val strBusiness: Business[String] = new Business[String] {
    def apply(str: String): Unit = println(s"Biz $str!")
  }
  implicit val intBusiness: Business[Int] = new Business[Int] {
    def apply(int: Int): Unit = println(s"Biz ${int + 1}!")
  }

  def apply[A](a: A)(implicit doBiz: Business[A]): Unit = doBiz.apply(a)
}
object SeriousBusiness {
  implicit val srsbsnsDouble = new Business[Double] {
    def apply(double: Double): Unit = println(s"Serious business $double")
  }
}
```

---

# Type classes: Operator Overloading

```tut
doBusiness(new BusinessString("hello"))
import Business._
Business("hello")
import SeriousBusiness._
Business(1.0)
```

???

Now let's take a look at where Type classes don't fit as well the OO parts of scala

---

# Be cautious with Type classes here...

```tut:silent
// inheritance
sealed trait RGB { def hex: String }
case object Red extends RGB { def hex: String = "F00" }
case object Green extends RGB { def hex: String = "0F0" }
case object Blue extends RGB { def hex: String = "00F" }

// type-class
sealed trait RGB
case object Red extends RGB
case object Green extends RGB
case object Blue extends RGB

trait Hex[A] {
  def value: String
}
object Hex {
  implicit val red = new Hex[Red.type] { def value: String = "F00" }
  implicit val green = new Hex[Green.type] { def value: String = "0F0" }
  implicit val blue = new Hex[Blue.type] { def value: String = "0F0" }
}
```

???

- Inheritance makes sense when you control all objects in your domain

---

# Be cautious with Type classes here...

### If you can't express a law on your type-class, it's probably not a type-class

```scala
f.map(identity) <-> f
deserialize(serialize(o)) <-> o
```

---

# Be cautious with Type classes here...

### When you know all the types that will ever need the functionality

```tut:silent
// interface
trait Describable { def desc: String }
object DomainObject1 extends Describable { val desc = "domain object 1" }
object DomainObject2 extends Describable { val desc = "domain object 2" }

// type-class
object DomainObject1
object DomainObject2

trait Describe[A] { def desc: String }
object Describe {
  implicit val object1 =
    new Describe[DomainObject1.type] { def desc: String = ??? }
  implicit val object2 =
    new Describe[DomainObject2.type] { def desc: String = ??? }
}

```
---

# Be cautious with Type classes here...

### If you start writing a type-class with a subclassing type-parameter, you might want plain subclassing

```tut:silent
trait Pet { def name: String }
case class Cat(name: String) extends Pet
case class Dog(name: String) extends Pet

// type-class
trait Greet[A <: Pet] {
  def apply(pet: A): String
}
object Greet {
  implicit val catGreet: Greet[Cat] = ???
  implicit val dogGreet: Greet[Dog] = ???
}

// regular method
def greet[A <: Pet](pet: A): String = s"Hello ${pet.name}"
```

---

# When Type classes are really the only option

- Returning the "current" type in Scala `this.copy(???)`
- Getting around F-bounded types `trait Foo[A <: Foo[A]]`
    https://tpolecat.github.io/2015/04/29/f-bounds.html
- Attaching generic behavior outside of declaration

???

- This question comes up a lot because Scala encourages immutability, so methods that return a modified copy of this are quite common. Making the return type of such methods sufficiently precise is tricky
- An F-bounded type is parameterized over its own subtypes, which allows us to “pass” the implementing type as an argument to the superclass.

---

# Only Type classes: "current" type

Returning the "current" type in Scala

```tut:silent:nofail
trait Foo {
  def bar: String
  def update(newBar: String): Foo
}

case class Baz(bar: String) extends Foo {
  def update(newBar: String): Baz = copy(bar = newBar)
}
```

---

# Only Type classes: "current" type

Returning the "current" type in Scala

```tut:silent:nofail
trait Foo {
  def bar: String
  def update(newBar: String): Foo
}

case class Baz(bar: String) extends Foo {
  def update(newBar: String): Baz = copy(bar = newBar)
}

```

We can still return the "wrong" type

```tut:nofail:book
case class Qux(bar: String, count: Int) extends Foo {
  def update(newBar: String): Baz = new Baz(newBar)
}
val q = Qux("Hi", 1)
val q2 = q.update("World")
```

---

# Only Type classes: "current" type

Returning the "current" type in Scala

```tut:silent:nofail
trait Foo {
  def bar: String
  def update(newBar: String): Foo
}

case class Baz(bar: String) extends Foo {
  def update(newBar: String): Baz = copy(bar = newBar)
}
```
We can't guarantee to return the same type as the receiver

```tut:fail

def exclaim[A <: Foo](foo: A): A = foo.update(foo.bar + "!")
```
???

- This fails because the return type of exclaim is not specific enough

---

# Only Type classes: "current" type

Returning the "current" type in Scala

```tut:silent:nofail
trait Foo {
  def bar: String
  def update(newBar: String): Foo
}

case class Baz(bar: String) extends Foo {
  def update(newBar: String): Baz = copy(bar = newBar)
}
```
The best we can do is return a `Foo`

```tut:nofail
def exclaim[A <: Foo](foo: A): Foo = foo.update(foo.bar + "!")
```

???

We have to widen to the super-class

---

# Only Type classes: "current" type

`self.type` might be the way

```tut:silent
trait Foo {
  def bar: String
  def update(newBar: String): this.type
}
```

---

# Only Type classes: "current" type

`self.type` might be the way

```tut:silent
trait Foo {
  def bar: String
  def update(newBar: String): this.type
}
```

But, this doesn't work...
```tut:fail
case class Baz(bar: String) extends Foo {
  def update(newBar: String): this.type = copy(bar = newBar)
}
```
---

# Only Type classes: "current" type


So, you have to cast, which defeats the purpose of type-safety
```tut:silent
case class Baz(bar: String) extends Foo {
  def update(newBar: String): this.type =
    copy(bar = newBar).asInstanceOf[this.type]
}
class Bar(override val bar: String) extends Baz(bar) {
  override def update(newBar: String): this.type =
    Baz(newBar).asInstanceOf[this.type]
}
```

```tut:fail
(new Bar("i'm a bar")).update("now i'm a baz, but i crash at runtime")
```

---

# Only Type classes: F-bounded type

F-bounded type with `self.type` has an strange syntax that gets you back some type-safety

```tut:reset:silent
trait Foo[A <: Foo[A]] { this: A =>
  def bar: String
  def update(newBar: String): A
}

case class Baz(bar: String) extends Foo[Baz] {
  def update(newBar: String): Baz = copy(bar = newBar)
}

def exclaim[A <: Foo[A]](foo: A): A = foo.update(foo.bar + "!")
```

```tut
exclaim(Baz("hello world"))
```

???

- An F-bounded type is parameterized over its own subtypes, so we can pass an implementing type as an argument to the superclass
---

# Only Type classes: F-bounded type

F-bounded type with `self.type` has an strange syntax that gets you back some type-safety

```tut:reset:silent
trait Foo[A <: Foo[A]] { this: A =>
  def bar: String
  def update(newBar: String): A
}

case class Baz(bar: String) extends Foo[Baz] {
  def update(newBar: String): Baz = copy(bar = newBar)
}
```
Now this fails properly
```tut:fail
case class Bar(bar: String) extends Foo[Baz]
```

---

# Only Type classes: F-bounded type

`self.type` still doesn't get you all the way there

```tut:reset:silent
trait Foo[A <: Foo[A]] { this: A =>
  def bar: String
  def update(newBar: String): A
}

case class Baz(bar: String) extends Foo[Baz] {
  def update(newBar: String): Baz = copy(bar = newBar)
}
```
Now we have gotten away from `self.type`
```tut:silent
class Bar(val bar: String) extends Foo[Bar] {
  def update(newBar: String) = new Bar(newBar)
}
class FooBar(bar: String) extends Bar(bar) // is Foo[Bar]
```

???

What if we replaced the `update` method with a type-class?

---

# Only Type classes: F-bounded type

Returning the "current" type in Scala

```tut:silent:nofail
trait Foo {
  def bar: String
}
trait Update[A] {
  def update(a: A, newBar: String): A
}
```
---

# Only Type classes: F-bounded type

Returning the "current" type in Scala

```tut:reset:silent:nofail
trait Foo {
  def bar: String
}
trait Update[A] {
  def update(a: A, newBar: String): A
}
```

Now we can define `Baz` and an *instance* of `Update[Baz]`

```tut:nofail:book:silent
object mainapp {
  case class Baz(bar: String) extends Foo
  object Baz {
    implicit val BazUpdate = new Update[Baz] {
      def update(a: Baz, newBar: String) = a.copy(bar = newBar)
    }
  }
}
```
---

# Only Type classes: F-bounded type

Returning the "current" type in Scala

```tut:nofail:book
import mainapp._
val b = Baz("Hello")
implicitly[Update[Baz]].update(b, "world")
```

---

# Only Type classes: behavior outside declaration

And we can add behavior as inline methods

```tut:nofail:book
implicit class UpdateOps[A](a: A)(implicit e: Update[A]) {
  def update(newBar: String) = e.update(a, newBar)
}

val hi = Baz("Hi")
hi.update("Bye")
```

---

# Wait... let's look at that again...

```tut:nofail
val hi = Baz("Hi")
hi.update("Bye")
```

But, the definition of `Baz` is:

```scala
case class Baz(bar: String) extends Foo
```

---

# Wait... let's look at that again...

```tut:nofail
val hi = Baz("Hi")
hi.update("Bye")
```

But, the definition of `Baz` is:

```scala
case class Baz(bar: String) extends Foo
```

This means that we can:
1. Use type-classes to define behavior on data
2. Attach operations on the data outside of data declaration

---

# To be clear...

```tut:nofail:book
case class Arglebargle(name: String)
case class Applesauce(brand: String)

implicit val argleBargleUpdate = new Update[Arglebargle] {
  def update(a: Arglebargle, name: String) = a.copy(name)
}
implicit val appleSauceUpdate = new Update[Applesauce] {
  def update(a: Applesauce, brand: String) = a.copy(brand)
}
Arglebargle("poppycock").update("grumble")
Applesauce("motts").update("grandma's")
```

---

# This is equivalent to...

```tut:nofail:book
trait Updateable[A] {
  def update(thing: String): A
}
case class Arglebargle(name: String) extends Updateable[Arglebargle] {
  def update(newName: String) = this.copy(name = newName)
}

case class Applesauce(brand: String) extends Updateable[Applesauce] {
  def update(newBrand: String) = this.copy(brand = newBrand)
}

Arglebargle("poppycock").update("grumble")
Applesauce("motts").update("grandma's")
```

---

# And this is equivalent to...

```tut:nofail:book
trait Foo {
  def name: String
  def update(newName: String): Foo
}
case class Arglebargle(name: String) extends Foo {
  def update(newName: String) = this.copy(name = newName)
}

case class Applesauce(brand: String) extends Foo {
  val name = brand
  def update(newBrand: String) = this.copy(brand = newBrand)
}

Arglebargle("poppycock").update("grumble")
Applesauce("motts").update("grandma's")
```

???

Inheritence and interfaces are replaceable with type-classes

---

# Only not really..

1. Inheritance/Mixin is not a guarantee that you return the correct type
2. And! You can do this with type-classes...


```tut:nofail:book
implicit val stringUpdate = new Update[String] {
  def update(a: String, newString: String) = newString
}
val hi = "Hello"
hi.update("world")

```

???

2. you can attach behavior to any type, outside of declaration

---

# Uses of type-classes

1. Anywhere you want to abstract over type-constructors
2. Anywhere where you need to return the current type
3. Anywhere to define behavior on any type:
    * even those you don't control
    * even those not yet written by future users of your code
4. Completely replace inheritance

---

# Uses of type-classes

1. Anywhere you want to abstract over type-constructors
2. Anywhere where you need to return the current type
3. Anywhere to define behavior on any type:
    * even those you don't control
    * even those not yet written by future users of your code
4. ~~Completely replace inheritance~~
5. Sometimes replace inheritance

???

no you shouldn't do 4

---

# Type-classes

Remember our `SaferDeserialize` implementation?

We now have satisfied two of our constraints...

1. ~~The API should never throw **non-fatal** exceptions~~
2. ~~Our solution should keep track at **compile-time** which types we can as~~
3. There should be little boilerplate

???

1. -- our deserializers never throw non-fatal exceptions, because we return a value representing failure in option
2. -- we let the compiler do the mapping of types to deserializers via type classes
3. -- we still have boilerplate, however, since we have to create instances for every type

---

# Reducing Boilerplate

Let's take a look back at our data types

```tut:silent
case class Person(name: String, age: Int)
case class Address(street: String, city: String, zip: Int)
case class Account(owner: String, balance: Double)
``` 

???

- What can we notice about these classes?

---
# Reducing Boilerplate

Let's take a look back at our data types

```tut:silent
case class Person(name: String, age: Int)
// (String, Int)
case class Address(street: String, city: String, zip: Int)
// (String, String, Int)
case class Account(owner: String, balance: Double)
// (String, Double)
``` 

???

- They all seem to be built from types like String, Int, Double
- What if we could somehow compose smaller deserializers into deserializers for more complicated case classes?

---
# Reducing Boilerplate

Here is what we'd like to be able to do:

```tut:silent:nofail
Deserialize[Person]("Fred,44")

case class Telephone(country: Int, area: Int, rest: Int)
Deserialize[Telephone]("1,415,5555555")
```

???

- we like to be able to make the compiler build deserializers for arbitrary case classes if we already have deserializers for the types those case classes use

---
# Reducing Boilerplate

Or even...

```tut:silent:nofail
"Fred,44".as[Person]

case class Telephone(country: Int, area: Int, rest: Int)
"1,415,5555555".as[Telephone]
```

---
# Reducing Boilerplate

And we want to be able to do this, too:

```tut:silent:nofail
case class Contact(person: Person,
                   telephone: Telephone,
                   address: Address)

Deserialize[Contact](
  "Fred,44,1,415,5555555,123 Bryant,San Francisco,94105"
)
```

---
# Reducing Boilerplate

And we want to be able to do this, too:

```tut:silent:nofail
case class Contact(person: Person,
                   telephone: Telephone,
                   address: Address)

Deserialize[Contact](
  "Fred,44,1,415,5555555,123 Bryant,San Francisco,94105"
)
```

With:
1. No exceptions
2. No runtime reflection
3. No boilerplate

---

# Reducing Boilerplate

```tut:silent:nofail
case class Person(name: String, age: Int)
case class Address(street: String, city: String, zip: Int)
case class Account(owner: String, balance: Double)
case class Telephone(country: Int, area: Int, rest: Int)
case class Contact(person: Person, telephone: Telephone, address: Address)
```

???

Take a look at our case classes, what is their shape?

---

# Reducing Boilerplate

```tut:silent:nofail
case class Person(name: String, age: Int)
// (String, Int)
case class Address(street: String, city: String, zip: Int)
// (String, String, Int)
case class Telephone(country: Int, area: Int, rest: Int)
// (Int, Int, Int)
case class Contact(person: Person, telephone: Telephone, address: Address)
// ((String, Int), (Int, Int, Int), (String, String, Int))
```

???

- These all de-sugar to named tuples of types

---

# Reducing Boilerplate

```tut:silent:nofail
// (String, Int)
// (String, String, Int)
// (Int, Int, Int)
// ((String, Int), (Int, Int, Int), (String, String, Int))
```

???

- Really there are only 2 types here

---

# Reducing Boilerplate

`String` and `Int`

???

- Reducing Boilerplate allows us to build up structures via induction

---

# Reducing Boilerplate

```tut:silent:nofail
case class Person(name: String, age: Int)
```

1. Recursively descend the parameters of the `Person`
2. Base case: I have an instance of `SaferDeserialize[String]` for `name: String`
3. Base case: I have an instance of `SaferDeserialize[Int]` for `age: Int`
4. Build a `SaferDeserialize[Person]` by using the `(SaferDeserialize[String], SaferDeserialize[Int])` instances

---

# Reducing Boilerplate

```tut:silent:nofail
case class Contact(person: Person, telephone: Telephone, address: Address)
```

1. Recursively descend the parameters of the `Contact`
2. Base case: I have an instance of `SaferDeserialize[Person]` for `name: Person` via induction
3. Base case: I have an instance of `SaferDeserialize[Telephone]` for `telephone: Telephone` via induction
3. Base case: I have an instance of `SaferDeserialize[Address]` for `address: Address` via induction
4. Build a `SaferDeserialize[Contact]` by using the `(SaferDeserialize[Person], SaferDeserialize[Telephone], SaferDeserialize[Address])` instances

---

# Reducing Boilerplate

So, let's see how we build this with Shapeless

---

class: center, middle

<h1>oh, wait.. this is a 20 min talk.</h1>

Andrew Kuhnhausen • `@kuhnhausen` • Domino Data Lab

16 November 2017 • Scale by the Bay

---


 </textarea>
    <script src="remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
